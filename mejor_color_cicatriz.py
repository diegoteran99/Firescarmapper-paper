# -*- coding: utf-8 -*-
"""
/***************************************************************************
 Example
                                 A QGIS plugin
 an example
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-10-07
        git sha              : $Format:%H$
        copyright            : (C) 2024 by diego
        email                : diego@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

from .resources import *
from .example_dialog import ExampleDialog
import os.path
from qgis.core import (Qgis, QgsProcessingAlgorithm,QgsProject, QgsRasterLayer, QgsProcessingException, 
                       QgsSingleBandPseudoColorRenderer, QgsRasterMinMaxOrigin, QgsProcessingFeedback, 
                       QgsColorRampShader, QgsRasterShader, QgsStyle, QgsContrastEnhancement)
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
import torch
from .firescarmapping.model_u_net import model, device
from .firescarmapping.as_dataset import create_datasetAS
import numpy as np
from torch.utils.data import DataLoader
import os
from osgeo import gdal, gdal_array
import requests
from qgis.PyQt.QtGui import QColor, QIcon
from qgis.PyQt.QtWidgets import QAction, QDialog, QVBoxLayout, QPushButton, QFileDialog

from PyQt5.QtWidgets import QVBoxLayout, QPushButton, QFileDialog, QLabel, QDialog, QTextEdit, QHBoxLayout, QMessageBox

class FireScarMapper(QgsProcessingAlgorithm):
    IN_BEFORE = "BeforeRasters"
    IN_AFTER = "AfterRasters"
    OUT_SCARS = "OutputScars"
    model_download_url = "https://fire2a-firescar-as-model.s3.amazonaws.com/ep25_lr1e-04_bs16_021__as_std_adam_f01_13_07_x3.model"
    model_path = os.path.join(os.path.dirname(__file__), 'firescarmapping', 'ep25_lr1e-04_bs16_021__as_std_adam_f01_13_07_x3.model')

    def processAlgorithm(self, parameters, context, feedback):
        if not os.path.exists(self.model_path):
            feedback.pushInfo("Model not found. Initializing download...")
            self.download_model(feedback)

        before_paths = parameters['BeforeRasters']
        #feedback.pushInfo(f"Input rasters:\n names: {[r.name() for r in before]}\ntypes: {[r.rasterType() for r in before]}")
        feedback.pushInfo(f"{before_paths=}")
        burnt_paths = parameters['AfterRasters']
        feedback.pushInfo(f"{burnt_paths=}")
        #feedback.pushInfo(f"Input rasters:\n names: {[r.name() for r in burnt]}\ntypes: {[r.rasterType() for r in burnt]}")
        before, burnt = [], []
        for i in range(len(before_paths)):
            before_name = parameters['BeforeRasters'][i].split("/")[-1]
            burnt_name = parameters['AfterRasters'][i].split("/")[-1]
            before.append(QgsRasterLayer(parameters['BeforeRasters'][i], before_name, "gdal"))
            burnt.append(QgsRasterLayer(parameters['AfterRasters'][i], burnt_name, "gdal"))

        model_path = os.path.join(os.path.dirname(__file__), 'firescarmapping', 'ep25_lr1e-04_bs16_021__as_std_adam_f01_13_07_x3.model')
        
        results_dir = os.path.join(os.path.dirname(__file__), 'results')
        if not os.path.exists(results_dir):
            os.makedirs(results_dir)
            feedback.pushInfo(f"Created results directory at: {results_dir}")

        # Asegurarse de que las capas sean listas de QgsRasterLayer
        if not isinstance(before, list) or not isinstance(burnt, list):
            raise QgsProcessingException("Input rasters must be lists of QgsRasterLayer")

        if len(before) != len(burnt):
            raise QgsProcessingException("The number of before and burnt rasters must be the same")
        
        rasters = []
        for i, layer in enumerate(before + burnt):
            adict = {
                "type": "before" if i < len(before) else "burnt",
                "id": i,
                "qid": layer.id(),
                "name": layer.name()[8:],
                "data": self.get_rlayer_data(layer),
                "layer": layer,
                "path": layer.dataProvider().dataSourceUri(),
                "output_path":os.path.join(results_dir, f"FireScar_{layer.name()[8:][0:]}")
            }
            adict.update(self.get_rlayer_info(layer))
            rasters += [adict]

        before_files = []
        after_files = []
        before_files_data = []
        after_files_data = []

        #Order rasters
        for i in range(len(rasters)//2):
            before_files.append(rasters[i])
            before_files_data.append(before_files[i]['data'])
            for j in range(len(rasters)//2): #starts iterating from the second half
                if rasters[i]['name'] == rasters[j + (len(rasters)//2)]['name']:
                    after_files.append(rasters[j + (len(rasters)//2)])
                    after_files_data.append(after_files[i]['data'])

        device = torch.device('cuda:0' if torch.cuda.is_available() else 'cpu')
        model.load_state_dict(torch.load(model_path, map_location=torch.device('cpu')))
        feedback.pushInfo(f"{before_files=}")
        np.random.seed(3)
        torch.manual_seed(3)    
        
        data_eval = create_datasetAS(before_files_data, after_files_data, mult=1)
        
        batch_size = 1 # 1 to create diagnostic images, any value otherwise
        all_dl = DataLoader(data_eval, batch_size=batch_size)

        model.eval()

        for i, batch in enumerate(all_dl):
            x = batch['img'].float().to(device)
            output = model(x).cpu()

            # obtain binary prediction map
            pred = np.zeros(output.shape)
            pred[output >= 0] = 1

            generated_matrix = pred[0][0]
            
            if before_files[i]['output_path']:
                
                group_name = before_files[i]['name'].split("_")[0] + "_" + before_files[i]['name'].split("_")[1]
                root = QgsProject.instance().layerTreeRoot()
                group = root.findGroup(group_name)
                if not group:
                    group = root.addGroup(group_name)
                
                # Colapsar el grupo para que se muestre minimizado en el panel de capas
                project_instance = QgsProject.instance()
                layer_tree = project_instance.layerTreeRoot().findGroup(group_name)
                if layer_tree:
                    layer_tree.setExpanded(False)

                
                self.writeRaster(generated_matrix, before_files[i]['output_path'], before_files[i], feedback)
                self.addRasterLayer(before_files[i]['output_path'],f"FireScar_{before_files[i]['name']}", group, context)
                self.addRasterLayer(after_files[i]['path'],f"ImgPosF_{after_files[i]['name']}", group, context)
                self.addRasterLayer(before_files[i]['path'],f"ImgPreF_{before_files[i]['name']}", group, context)
        return {}
        
    
    def download_model(self, feedback):
        """Download the model from Amazon S3 with progress feedback."""
        
        def save_response_content(response, destination, feedback, total_size):
            """Guardar el contenido descargado en el archivo de destino con retroalimentación de progreso."""
            CHUNK_SIZE = 1048576  # 1 MB
            bytes_downloaded = 0
            
            with open(destination, "wb") as f:
                for chunk in response.iter_content(CHUNK_SIZE):
                    if chunk:  # Filtrar los "keep-alive" chunks vacíos
                        f.write(chunk)
                        bytes_downloaded += len(chunk)

                        # Calcular el porcentaje de descarga completada
                        progress = (bytes_downloaded / total_size) * 100

                        # Usar setProgress solo si está disponible en el feedback
                        if hasattr(feedback, 'setProgress'):
                            feedback.setProgress(int(progress))

                        # Informar el progreso en MB
                        feedback.pushInfo(f"Downloaded {bytes_downloaded // (1024 * 1024)} MB of {total_size // (1024 * 1024)} MB")

        # Iniciar una sesión persistente para reutilizar la conexión
        session = requests.Session()
        
        try:
            # Intentar realizar la solicitud con un timeout y streaming habilitado
            response = session.get(self.model_download_url, stream=True, timeout=30)
            response.raise_for_status()  # Lanza una excepción si la descarga falla

            # Obtener el tamaño total del archivo desde los encabezados de la respuesta
            total_size = int(response.headers.get('Content-Length', 0))
            if total_size == 0:
                raise requests.exceptions.RequestException("Unable to determine the file size.")

            # Informar sobre el inicio de la descarga
            feedback.pushInfo(f"Downloading model to {self.model_path} ({total_size // (1024 * 1024)} MB)")

            # Guardar el contenido descargado
            save_response_content(response, self.model_path, feedback, total_size)

            # Informar que la descarga ha sido exitosa
            feedback.pushInfo(f"Model successfully downloaded and saved at {self.model_path}")
        
        except requests.exceptions.RequestException as e:
            # Manejo de cualquier error que pueda ocurrir durante la solicitud
            feedback.pushInfo(f"Failed to download model: {str(e)}")
    

    def qgis2numpy_dtype(self, qgis_dtype: Qgis.DataType) -> np.dtype:
        """Conver QGIS data type to corresponding numpy data type
        https://raw.githubusercontent.com/PUTvision/qgis-plugin-deepness/fbc99f02f7f065b2f6157da485bef589f611ea60/src/deepness/processing/processing_utils.py
        This is modified and extended copy of GDALDataType.

        * ``UnknownDataType``: Unknown or unspecified type
        * ``Byte``: Eight bit unsigned integer (quint8)
        * ``Int8``: Eight bit signed integer (qint8) (added in QGIS 3.30)
        * ``UInt16``: Sixteen bit unsigned integer (quint16)
        * ``Int16``: Sixteen bit signed integer (qint16)
        * ``UInt32``: Thirty two bit unsigned integer (quint32)
        * ``Int32``: Thirty two bit signed integer (qint32)
        * ``Float32``: Thirty two bit floating point (float)
        * ``Float64``: Sixty four bit floating point (double)
        * ``CInt16``: Complex Int16
        * ``CInt32``: Complex Int32
        * ``CFloat32``: Complex Float32
        * ``CFloat64``: Complex Float64
        * ``ARGB32``: Color, alpha, red, green, blue, 4 bytes the same as QImage.Format_ARGB32
        * ``ARGB32_Premultiplied``: Color, alpha, red, green, blue, 4 bytes  the same as QImage.Format_ARGB32_Premultiplied
        """
        if qgis_dtype == Qgis.DataType.Byte or qgis_dtype == "Byte":
            return np.uint8
        if qgis_dtype == Qgis.DataType.UInt16 or qgis_dtype == "UInt16":
            return np.uint16
        if qgis_dtype == Qgis.DataType.Int16 or qgis_dtype == "Int16":
            return np.int16
        if qgis_dtype == Qgis.DataType.Float32 or qgis_dtype == "Float32":
            return np.float32
        if qgis_dtype == Qgis.DataType.Float64 or qgis_dtype == "Float64":
            return np.float64

    def get_rlayer_info(self, layer: QgsRasterLayer):
        """Get raster layer info: width, height, extent, crs, cellsize_x, cellsize_y, nodata list, number of bands.

        Args:
            layer (QgsRasterLayer): A raster layer
        Returns:
            dict: raster layer info
        """
        provider = layer.dataProvider()
        ndv = []
        for band in range(1, layer.bandCount() + 1):
            ndv += [None]
            if provider.sourceHasNoDataValue(band):
                ndv[-1] = provider.sourceNoDataValue(band)
        return {
            "width": layer.width(),
            "height": layer.height(),
            "extent": layer.extent(),
            "crs": layer.crs(),
            "cellsize_x": layer.rasterUnitsPerPixelX(),
            "cellsize_y": layer.rasterUnitsPerPixelY(),
            "nodata": ndv,
            "bands": layer.bandCount(),
        }


    def get_rlayer_data(self, layer: QgsRasterLayer):
        """Get raster layer data (EVERY BAND) as numpy array; Also returns nodata value, width and height
        The user should check the shape of the data to determine if it is a single band or multiband raster.
        len(data.shape) == 2 for single band, len(data.shape) == 3 for multiband.

        Args:
            layer (QgsRasterLayer): A raster layer

        Returns:
            data (np.array): Raster data as numpy array
            nodata (None | list): No data value
            width (int): Raster width
            height (int): Raster height

        FIXME? can a multiband raster have different nodata values and/or data types for each band?
        TODO: make a band list as input
        """
        provider = layer.dataProvider()
        if layer.bandCount() == 1:
            block = provider.block(1, layer.extent(), layer.width(), layer.height())
            nodata = None
            if block.hasNoDataValue():
                nodata = block.noDataValue()
            np_dtype = self.qgis2numpy_dtype(provider.dataType(1))
            data = np.frombuffer(block.data(), dtype=np_dtype).reshape(layer.height(), layer.width())
        else:
            data = []
            nodata = []
            np_dtype = []
            for i in range(layer.bandCount()):
                block = provider.block(i + 1, layer.extent(), layer.width(), layer.height())
                nodata += [None]
                if block.hasNoDataValue():
                    nodata[-1] = block.noDataValue()
                np_dtype += [self.qgis2numpy_dtype(provider.dataType(i + 1))]
                data += [np.frombuffer(block.data(), dtype=np_dtype[-1]).reshape(layer.height(), layer.width())]
            # would different data types bug this next line?
            data = np.array(data)
        # return data, nodata, np_dtype
        return data

    def writeRaster(self, matrix, file_path, before_layer, feedback):

        # Get the dimensions of the raster before the fire
        width = before_layer["width"]
        height = before_layer["height"]

        # Create the output raster file
        driver = gdal.GetDriverByName('GTiff')
        raster = driver.Create(file_path, width, height, 1, gdal.GDT_Byte)

        if raster is None:
            raise QgsProcessingException("Failed to create raster file.")

        # Set the geotransformation and projection
        extent = before_layer["extent"]
        pixel_width = extent.width() / width
        pixel_height = extent.height() / height
        raster.SetGeoTransform((extent.xMinimum(), pixel_width, 0, extent.yMaximum(), 0, -pixel_height))
        raster.SetProjection(before_layer["crs"].toWkt())

        # Get the raster band
        band = raster.GetRasterBand(1)

        # Calculate the offset and size of the burn scar region to fit the raster
        start_row = 0
        start_col = 0
        matrix_height, matrix_width = matrix.shape

        if matrix_height > height:
            start_row = (matrix_height - height) // 2
            matrix_height = height
        if matrix_width > width:
            start_col = (matrix_width - width) // 2
            matrix_width = width

        # Crop the matrix to match the raster dimensions
        resized_matrix = matrix[start_row:start_row + matrix_height, start_col:start_col + matrix_width]

        # Write the matrix to the raster band
        try:
            gdal_array.BandWriteArray(band, resized_matrix, 0, 0)
        except ValueError as e:
            raise QgsProcessingException(f"Failed to write array to raster: {str(e)}")

        # Set the NoData value
        band.SetNoDataValue(0)
        
        # Ensure that the minimum and maximum values are updated
        band.ComputeStatistics(False)
        band.SetStatistics(0, 1, 0.5, 0.5)

        # Flush cache and close the raster
        band.FlushCache()
        raster.FlushCache()
        raster = None

        feedback.pushInfo(f"Raster written to {file_path}")

    def addRasterLayer(self, file_path, layer_name, group, context):
        """Añadir la capa raster al grupo en el proyecto."""
        layer = QgsRasterLayer(file_path, layer_name, "gdal")
        if not layer.isValid():
            raise QgsProcessingException(f"Failed to load raster layer from {file_path}")

        # Añadir la capa al proyecto sin mostrarla
        QgsProject.instance().addMapLayer(layer, False)
        group.addLayer(layer)

        # Si el nombre de la capa contiene "FireScar", cambiar el renderer a singleband pseudocolor
        if "FireScar" in layer_name:
            # Forzar el cálculo de las estadísticas de la banda para obtener los valores correctos
            provider = layer.dataProvider()
            stats = provider.bandStatistics(1, QgsRasterMinMaxOrigin.Estimated)
            min_value = stats.minimumValue
            max_value = stats.maximumValue

            # Crear un shader de color para interpolar entre colores
            shader = QgsRasterShader()
            color_ramp_shader = QgsColorRampShader(minimumValue=min_value, maximumValue=max_value)
            color_ramp_shader.setColorRampType(QgsColorRampShader.Interpolated)

            # Usar el estilo "Reds" de la lista de estilos de QGIS
            style = QgsStyle().defaultStyle()
            ramp = style.colorRamp('Reds')
            if ramp:
                color_ramp_shader.setSourceColorRamp(ramp)

            shader.setRasterShaderFunction(color_ramp_shader)

            # Crear el renderer con el shader
            renderer = QgsSingleBandPseudoColorRenderer(layer.dataProvider(), 1, shader)

            # Asignar el renderer a la capa
            layer.setRenderer(renderer)

            # Actualizar el rango de contraste para asegurarse de que se muestren correctamente
            layer.setContrastEnhancement(QgsContrastEnhancement.StretchToMinimumMaximum)

            # Forzar la actualización del renderizador
            layer.triggerRepaint()
            layer.reload()









    def name(self):
        return "firescarmapper"
    
    def displayName(self):
        return self.tr("Fire Scar Mapper")

    def tr(self, string):
        return QCoreApplication.translate("Processing", string)

    def createInstance(self):
        return FireScarMapper()




class LayerSelectionDialog(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.resize(800, 600) 

        # Descripción del proceso (añadido)
        self.description_label = QTextEdit(self)
        self.description_label.setReadOnly(True)
        self.description_label.setHtml(self.get_description())  # Set HTML content

        # Selector para imágenes pre-incendio
        self.pre_fire_button = QPushButton("Select Pre-Fire Images")
        self.pre_fire_button.clicked.connect(self.select_pre_fire_files)

        # Selector para imágenes post-incendio
        self.post_fire_button = QPushButton("Select Post-Fire Images")
        self.post_fire_button.clicked.connect(self.select_post_fire_files)

        # Campo de texto para mostrar las rutas seleccionadas de imágenes pre-incendio
        self.pre_fire_display = QTextEdit(self)
        self.pre_fire_display.setReadOnly(True)
        self.pre_fire_display.setPlaceholderText("Pre-fire images will be displayed here...")

        # Campo de texto para mostrar las rutas seleccionadas de imágenes post-incendio
        self.post_fire_display = QTextEdit(self)
        self.post_fire_display.setReadOnly(True)
        self.post_fire_display.setPlaceholderText("Post-fire images will be displayed here...")

        # Botón para ejecutar el procesamiento
        self.run_button = QPushButton("Run Fire Scar Mapping")
        self.run_button.clicked.connect(self.run_fire_scar_mapping)

        # Layout para la izquierda: selectores de imágenes y campo de texto
        left_layout = QVBoxLayout()
        left_layout.addWidget(self.pre_fire_button)
        left_layout.addWidget(self.pre_fire_display)
        left_layout.addWidget(self.post_fire_button)
        left_layout.addWidget(self.post_fire_display)
        left_layout.addWidget(self.run_button)

        # Layout principal: distribución en dos columnas (selectores a la izquierda, descripción a la derecha)
        main_layout = QHBoxLayout()
        main_layout.addLayout(left_layout)  # Columna izquierda
        main_layout.addWidget(self.description_label, stretch=1)  # Columna derecha con descripción

        self.setLayout(main_layout)

        # Almacenar las rutas de los archivos seleccionados
        self.pre_fire_files = []
        self.post_fire_files = []

    def get_description(self):
        """Obtener la descripción del plugin en formato HTML."""
        return """
            <h1>Fire Scar Mapper</h1><br>

            <b>Objective:</b> Generate fire scars using a pre-trained U-Net model and analyze the differences between pre- and post-fire satellite images.<br>

            <b>Process:</b> 
            Fire scars are identified by comparing the spectral differences between pre-fire and post-fire satellite images.<br>

            <b>Constraints:</b><br>
            (a) Pre- and post-fire images must have the same geographical extent and must be cropped to the affected area.<br>
            (b) Fire scars are calculated only within the affected areas.<br>

            <b>Inputs:</b><br>
            (i) A <b>pre-fire</b> raster layer containing the necessary spectral bands for analysis.<br>
            (ii) A <b>post-fire</b> raster layer containing the necessary spectral bands for analysis.<br>
            - Both images must be georeferenced and have the same spatial resolution.<br>

            <b>File Naming Format:</b><br>
            All image files must follow this naming convention:<br>
            <code>&lt;ImgPreF or ImgPosF&gt;_&lt;locality code&gt;_&lt;ID&gt;_&lt;threshold&gt;_&lt;year/month/day&gt;_clip.tif</code><br>
            For example:<br>
            <code>ImgPreF_CL-BI_ID74101_u350_19980330_clip.tif</code><br>

            <b>Considerations:</b><br>
            - The segmentation model is pre-trained and stored locally, and it will only be downloaded when necessary.<br>
            - In the pre- and post-fire image layers, the red and blue bands are swapped. You can fix this manually by adjusting the symbology properties of each layer.

        """

    def select_pre_fire_files(self):
        """Seleccionar las imágenes pre-incendio y mostrarlas en el campo de texto."""
        self.pre_fire_files, _ = QFileDialog.getOpenFileNames(self, "Select Pre-Fire Images", "", "Images (*.tif *.jpg *.png)")
        if self.pre_fire_files:
            self.pre_fire_display.setText("\n".join(self.pre_fire_files))

    def select_post_fire_files(self):
        """Seleccionar las imágenes post-incendio y mostrarlas en el campo de texto."""
        self.post_fire_files, _ = QFileDialog.getOpenFileNames(self, "Select Post-Fire Images", "", "Images (*.tif *.jpg *.png)")
        if self.post_fire_files:
            self.post_fire_display.setText("\n".join(self.post_fire_files))

    def run_fire_scar_mapping(self):
        """Ejecutar el procesamiento una vez seleccionadas las imágenes."""
        pre_fire_files = self.pre_fire_files
        post_fire_files = self.post_fire_files

        # Verificar que se hayan seleccionado imágenes
        if not pre_fire_files or not post_fire_files:
            QMessageBox.warning(self, "Error", "Please select both pre-fire and post-fire images.")
            return

        # Crear un feedback para mostrar el progreso y los mensajes
        feedback = QgsProcessingFeedback()

        # Ejecutar el algoritmo de FireScarMapper
        scar_mapper = FireScarMapper()

        parameters = {
            'BeforeRasters': pre_fire_files,
            'AfterRasters': post_fire_files,
            'OutputScars': os.path.join(os.path.dirname(__file__), 'results', 'OutputScar.tif')
        }

        # Pasamos el feedback para evitar el error
        scar_mapper.processAlgorithm(parameters, context=None, feedback=feedback)

        feedback.pushInfo("Fire scar mapping process completed successfully.")

        self.close()




class Example:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'Example_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Example')

        # Check if plugin was started the first time in current QGIS session
        self.first_start = None

    def tr(self, message):
        """Get the translation for a string using Qt translation API."""
        return QCoreApplication.translate('Example', message)

    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar."""
        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""
        icon_path = ':/plugins/example/icon.png'

        # Crear un botón para disparar el diálogo de selección y procesamiento
        self.add_action(
            icon_path,
            text=self.tr(u'Generate Fire Scars'),
            callback=self.show_layer_selection_dialog,  # Cambiado aquí
            parent=self.iface.mainWindow()
        )

        self.first_start = True

    def show_layer_selection_dialog(self):
        """Muestra el diálogo para seleccionar las capas y ejecutar el mapeo."""
        dialog = LayerSelectionDialog(self.iface.mainWindow())  # Asegúrate de pasar el parent correcto
        dialog.exec_()  # Muestra la ventana de diálogo

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Example'),
                action)
            self.iface.removeToolBarIcon(action)

    def run(self):
        """Run method that performs all the real work"""
        # Crear la clase FireScarMapper y registrarla en el contexto de procesamiento
        scar_mapper = FireScarMapper()
        scar_mapper.processAlgorithm({}, self.iface, feedback=self.iface.messageBar())

        # Mostrar cualquier mensaje en el diálogo
        if self.first_start:
            self.first_start = False
            self.dlg = ExampleDialog()

        # Mostrar el diálogo
        self.dlg.show()
        result = self.dlg.exec_()
        if result:
            pass
